# Report

## Chord
### 文件结构
- `node.go`  构建了需要用到的结构体以及其方法，实现了外部接口
- `hash.go`  实现了获取hash值的函数，判断是否处于区间的函数，以及计算了需要用到的2的幂次

### 基本思想
在Chord中，每个节点的地址通过sha-1哈希映射成一个160位的整数，排列成一个环。同样，每个数据的key也被映射成一个160位整数，排列在环上。每个环上成员的successor定义为该环上沿顺时针方向上的第一个成员。每个数据被储存在它的successor中，每个节点会记录自己的successor。在查找一个成员的successor时，主要通过`FindSuccessor`,`FindPredecessor`和`ClosestPrecedingFinger`三个函数实现。

每个节点会记录一个大小为160的finger_table，记录距离自己2的i次方的成员的successor，这会在`ClosestPrecedingFinger`中被用到。这可以大大提高查找的效率，因为每次跳转都可以减少一半的距离。finger_table的第一个元素就是successor，只需保证successor是正确的，就可以通过每次短距离的跳转最后得到正确的结果。`Stabilize`和`Notify`可以修改节点的前驱和后继,`FixFingers`会每次维护一个节点的finger_table的某一个元素。`Maintain`函数会定期执行`Stabilize`和`FixFingers`，以维护环形结构。

普通节点的退出`Quit`会通知其他节点，直接修改前驱的后继和后继的前驱，并进行数据转移。节点的异常退出`Forcequit`不会通知其他节点，为了应对这种情况，每个节点不只储存一个successor，而是储存一个successor列表，并在获取successor时进行检查，如果掉线则进行更新，以保证查找的顺利进行。同时，每个节点会储存它的前驱的数据备份，当前驱掉线时，可以用自己的数据备份进行恢复。

### 一些细节
- 如果要用RPC调用，则结构体名字开头和方法名字开头必须要大写，并且不能含有下划线。方法的结构必须满足只有两个参数，第二个参数是一个指针，作为结果，返回值必须是error类型。
- 如果一个节点在执行`Quit`函数时，进入了`Stabilize`函数，那么可能会把后继和前驱更改后的信息改回来，导致后面的查找出现错误。为了防止这种情况，要加一个stabilizelock，每次`Stabilize`前后加上锁，同时在`Quit`函数一开始上锁，最后解锁。这样可以在`Quit`时阻塞`Stabilize`，防止出错。
- 为了`Maintain`正常进行，不只要在获取后继时检查后继是否有效，也要定期检查前驱，`CheckPredecessor`实现了该功能。
- 在我的实现中，我只在一个节点的前驱变化时会进行数据的转移。如果改成只在后继变化进行转移应该也是一样的，但是可能更麻烦一点。在节点掉线时，不只要把数据和备份转移给后继，还要把后继的备份转移到后继的后继。同样，在`Notify`时，如果发现了新的前驱，则应该把属于它的数据和备份转移给它，并且修改自己的备份。


## Kademlia
### 文件结构
- `node.go` 构建了需要使用的结构体和主体函数并实现外部接口
- `bucket.go` 通过数组模拟了链表及其方法，加上锁之后可作为k-bucket和获取的节点列表的结构体
- `hash.go` 除最基本的计算哈希值函数外，还实现了异或距离以及对应的k-bucket编号的函数
### 基本思想
kademlia也采用了sha-1哈希把每个节点的地址和数据的键值映射成了一个160整数。每个节点有160个k-bucket，大小为k，这里取的20。第i个k-bucket中的节点与自身的异或距离在2^i到2^(i+1)之间。`Lookup`函数可以获得与目标节点最近的k个节点列表，它调用了`FindNode`函数来获得自己已知的最近的k个节点。`FindNode`函数先定位到该节点应该在自身的哪个k-bucket中，从中取出离该节点最近的k个节点，如果不够就用其他k-bucket中的节点来补充。但是这里获取的k个节点只是自己的k-bucket里的，不一定是最近的，因此接下来在`Lookup`中要用`FindNode`获得的k个节点，每次选出没有访问过的a个节点（这里是3），继续调用`FindNode`获取节点列表，并用这些节点列表去更新答案，当找不到更近的节点并且k个节点都访问过时，结束，返回答案。

在`Join`的过程中，通过查找自己，可以更新自己的k-bucket。

在`Put`时，把数据存储到离它的键值异或距离最近的k个节点。在`Get`时，过程类似于`Lookup`，只不过在找到数据后就直接返回，否则也不断进行迭代去寻找。

节点在正常退出时，会把自己的数据全都重新发布一遍，这样不会减少储存数据节点的数量。kademlia通过把数据储存在多个节点中，可以降低数据丢失的风险。对于异常退出的节点，因为数据还在其它节点储存了很多份，所以只要不全部退出，还是可以查找到的。相比于chord，kademlia不需要进行过多的维护就能保证正确性。

### 一些细节
- kademlia协议要求每次发出RPC请求时，接收方要更新发送方所在的k-bucket，所以那些要调用的函数都进行了封装，将需要的参数和发送方，接收方一起封装成了新的参数。
- RPC调用的函数的参数如果是自己写的结构体，则不能含有锁。
- 在kademlia中，传入退出信号的channel必须要设置缓冲大小为1，否则在传入的时候会卡住。（但是在chord中就不会有这个问题）
- 要注意在更新答案列表时不能仅看是否在线以及距离是否更近，要注意不能重复。（否则最后找到的k个节点都是一样的，卡了我很久）
- 最好在每次更新列表时都判断一下是否在线，否则最后可能进入死循环，每次都用不在线的节点更新列表。
- 尽量不要在比较通用的结构体中加锁，可以加锁后额外用一个新的结构体包装。